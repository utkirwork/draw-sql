"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLExportService = void 0;
class SQLExportService {
    /**
     * Generate SQL schema from diagram data
     */
    generateSQLSchema(tables, relationships, databaseType = 'postgresql', schemaName = 'public') {
        const sqlStatements = [];
        // Add header comment
        sqlStatements.push('-- ================================================');
        sqlStatements.push('-- Database Schema Generated by DrawSQL');
        sqlStatements.push(`-- Generated at: ${new Date().toISOString()}`);
        sqlStatements.push(`-- Database Type: ${databaseType.toUpperCase()}`);
        sqlStatements.push(`-- Schema: ${schemaName}`);
        sqlStatements.push('-- ================================================\n');
        // Create schema if not exists (for PostgreSQL)
        if (databaseType === 'postgresql' && schemaName !== 'public') {
            sqlStatements.push(`CREATE SCHEMA IF NOT EXISTS "${schemaName}";\n`);
        }
        // Generate CREATE TABLE statements
        tables.forEach(table => {
            sqlStatements.push(this.generateCreateTableSQL(table, databaseType, schemaName));
            sqlStatements.push('');
        });
        // Generate foreign key constraints
        const foreignKeyConstraints = this.generateForeignKeyConstraints(relationships, databaseType, schemaName);
        if (foreignKeyConstraints.length > 0) {
            sqlStatements.push('-- ================================================');
            sqlStatements.push('-- Foreign Key Constraints');
            sqlStatements.push('-- ================================================\n');
            sqlStatements.push(...foreignKeyConstraints);
        }
        // Generate indexes
        const indexes = this.generateIndexes(tables, databaseType, schemaName);
        if (indexes.length > 0) {
            sqlStatements.push('-- ================================================');
            sqlStatements.push('-- Indexes');
            sqlStatements.push('-- ================================================\n');
            sqlStatements.push(...indexes);
        }
        return sqlStatements.join('\n');
    }
    /**
     * Generate CREATE TABLE statement for a single table
     */
    generateCreateTableSQL(table, databaseType, schemaName) {
        const statements = [];
        // Table comment
        if (table.description) {
            statements.push(`-- Table: ${table.name}`);
            statements.push(`-- Description: ${table.description}\n`);
        }
        // Start CREATE TABLE statement
        const tableName = this.quoteIdentifier(table.name, databaseType);
        const schemaPrefix = schemaName !== 'public' ? `${this.quoteIdentifier(schemaName, databaseType)}.` : '';
        statements.push(`CREATE TABLE ${schemaPrefix}${tableName} (`);
        // Generate column definitions
        const columnDefinitions = [];
        const primaryKeys = [];
        if (table.columns) {
            table.columns.forEach((column, index) => {
                const columnDef = this.generateColumnDefinition(column, databaseType);
                columnDefinitions.push(`    ${columnDef}`);
                if (column.is_primary_key) {
                    primaryKeys.push(this.quoteIdentifier(column.name, databaseType));
                }
            });
        }
        // Add primary key constraint if there are primary keys
        if (primaryKeys.length > 0) {
            columnDefinitions.push(`    PRIMARY KEY (${primaryKeys.join(', ')})`);
        }
        statements.push(columnDefinitions.join(',\n'));
        statements.push(');');
        // Add table comment
        if (table.description) {
            const commentSQL = this.generateCommentSQL(table, databaseType, schemaName);
            if (commentSQL) {
                statements.push(commentSQL);
            }
        }
        return statements.join('\n');
    }
    /**
     * Generate column definition
     */
    generateColumnDefinition(column, databaseType) {
        const parts = [];
        // Column name
        parts.push(this.quoteIdentifier(column.name, databaseType));
        // Data type with length/precision
        const dataType = this.mapDataType(column, databaseType);
        parts.push(dataType);
        // NOT NULL constraint
        if (!column.is_nullable) {
            parts.push('NOT NULL');
        }
        // Default value
        if (column.default_value) {
            parts.push(`DEFAULT ${this.formatDefaultValue(column.default_value, column.data_type)}`);
        }
        // Unique constraint
        if (column.is_unique && !column.is_primary_key) {
            parts.push('UNIQUE');
        }
        // Column comment
        if (column.description) {
            const comment = this.escapeString(column.description, databaseType);
            parts.push(`COMMENT '${comment}'`);
        }
        return parts.join(' ');
    }
    /**
     * Map data types to database-specific types
     */
    mapDataType(column, databaseType) {
        const { data_type, length, precision, scale } = column;
        switch (databaseType) {
            case 'postgresql':
                return this.mapPostgreSQLType(data_type, length, precision, scale);
            case 'mysql':
                return this.mapMySQLType(data_type, length, precision, scale);
            case 'sqlserver':
                return this.mapSQLServerType(data_type, length, precision, scale);
            case 'mariadb':
                return this.mapMariaDBType(data_type, length, precision, scale);
            default:
                return data_type;
        }
    }
    mapPostgreSQLType(dataType, length, precision, scale) {
        switch (dataType) {
            case 'varchar':
                return length ? `VARCHAR(${length})` : 'VARCHAR';
            case 'char':
                return length ? `CHAR(${length})` : 'CHAR(1)';
            case 'decimal':
            case 'numeric':
                if (precision && scale) {
                    return `NUMERIC(${precision},${scale})`;
                }
                else if (precision) {
                    return `NUMERIC(${precision})`;
                }
                return 'NUMERIC';
            case 'integer':
                return 'INTEGER';
            case 'bigint':
                return 'BIGINT';
            case 'smallint':
                return 'SMALLINT';
            case 'serial':
                return 'SERIAL';
            case 'bigserial':
                return 'BIGSERIAL';
            case 'boolean':
                return 'BOOLEAN';
            case 'date':
                return 'DATE';
            case 'time':
                return 'TIME';
            case 'timestamp':
                return 'TIMESTAMP';
            case 'timestamptz':
                return 'TIMESTAMPTZ';
            case 'json':
                return 'JSON';
            case 'jsonb':
                return 'JSONB';
            case 'uuid':
                return 'UUID';
            case 'bytea':
                return 'BYTEA';
            case 'inet':
                return 'INET';
            case 'cidr':
                return 'CIDR';
            case 'macaddr':
                return 'MACADDR';
            case 'text':
                return 'TEXT';
            default:
                return dataType.toUpperCase();
        }
    }
    mapMySQLType(dataType, length, precision, scale) {
        switch (dataType) {
            case 'varchar':
                return length ? `VARCHAR(${length})` : 'VARCHAR(255)';
            case 'char':
                return length ? `CHAR(${length})` : 'CHAR(1)';
            case 'decimal':
            case 'numeric':
                if (precision && scale) {
                    return `DECIMAL(${precision},${scale})`;
                }
                else if (precision) {
                    return `DECIMAL(${precision})`;
                }
                return 'DECIMAL';
            case 'integer':
                return 'INT';
            case 'bigint':
                return 'BIGINT';
            case 'smallint':
                return 'SMALLINT';
            case 'serial':
                return 'INT AUTO_INCREMENT';
            case 'bigserial':
                return 'BIGINT AUTO_INCREMENT';
            case 'boolean':
                return 'BOOLEAN';
            case 'date':
                return 'DATE';
            case 'time':
                return 'TIME';
            case 'timestamp':
                return 'TIMESTAMP';
            case 'timestamptz':
                return 'TIMESTAMP';
            case 'json':
                return 'JSON';
            case 'jsonb':
                return 'JSON';
            case 'uuid':
                return 'VARCHAR(36)';
            case 'text':
                return 'TEXT';
            default:
                return dataType.toUpperCase();
        }
    }
    mapSQLServerType(dataType, length, precision, scale) {
        switch (dataType) {
            case 'varchar':
                return length ? `VARCHAR(${length})` : 'VARCHAR(255)';
            case 'char':
                return length ? `CHAR(${length})` : 'CHAR(1)';
            case 'decimal':
            case 'numeric':
                if (precision && scale) {
                    return `DECIMAL(${precision},${scale})`;
                }
                else if (precision) {
                    return `DECIMAL(${precision})`;
                }
                return 'DECIMAL';
            case 'integer':
                return 'INT';
            case 'bigint':
                return 'BIGINT';
            case 'smallint':
                return 'SMALLINT';
            case 'serial':
                return 'INT IDENTITY(1,1)';
            case 'bigserial':
                return 'BIGINT IDENTITY(1,1)';
            case 'boolean':
                return 'BIT';
            case 'date':
                return 'DATE';
            case 'time':
                return 'TIME';
            case 'timestamp':
                return 'DATETIME2';
            case 'timestamptz':
                return 'DATETIMEOFFSET';
            case 'json':
                return 'NVARCHAR(MAX)';
            case 'jsonb':
                return 'NVARCHAR(MAX)';
            case 'uuid':
                return 'UNIQUEIDENTIFIER';
            case 'text':
                return 'TEXT';
            default:
                return dataType.toUpperCase();
        }
    }
    mapMariaDBType(dataType, length, precision, scale) {
        // MariaDB is similar to MySQL
        return this.mapMySQLType(dataType, length, precision, scale);
    }
    /**
     * Generate foreign key constraints
     */
    generateForeignKeyConstraints(relationships, databaseType, schemaName) {
        const statements = [];
        relationships.forEach(rel => {
            const constraintName = rel.constraint_name || `fk_${rel.from_table_id}_${rel.to_table_id}`;
            const schemaPrefix = schemaName !== 'public' ? `${this.quoteIdentifier(schemaName, databaseType)}.` : '';
            const statement = `ALTER TABLE ${schemaPrefix}${this.quoteIdentifier(rel.from_table_id, databaseType)} ` +
                `ADD CONSTRAINT ${this.quoteIdentifier(constraintName, databaseType)} ` +
                `FOREIGN KEY (${this.quoteIdentifier(rel.from_column_id, databaseType)}) ` +
                `REFERENCES ${schemaPrefix}${this.quoteIdentifier(rel.to_table_id, databaseType)} ` +
                `(${this.quoteIdentifier(rel.to_column_id, databaseType)}) ` +
                `ON DELETE ${rel.on_delete || 'RESTRICT'} ` +
                `ON UPDATE ${rel.on_update || 'RESTRICT'};`;
            statements.push(statement);
        });
        return statements;
    }
    /**
     * Generate indexes
     */
    generateIndexes(tables, databaseType, schemaName) {
        const statements = [];
        tables.forEach(table => {
            if (table.columns) {
                // Generate indexes for foreign keys
                table.columns.forEach(column => {
                    if (column.is_foreign_key) {
                        const indexName = `idx_${table.name}_${column.name}`;
                        const schemaPrefix = schemaName !== 'public' ? `${this.quoteIdentifier(schemaName, databaseType)}.` : '';
                        const statement = `CREATE INDEX ${this.quoteIdentifier(indexName, databaseType)} ` +
                            `ON ${schemaPrefix}${this.quoteIdentifier(table.name, databaseType)} ` +
                            `(${this.quoteIdentifier(column.name, databaseType)});`;
                        statements.push(statement);
                    }
                });
            }
        });
        return statements;
    }
    /**
     * Generate table comment
     */
    generateCommentSQL(table, databaseType, schemaName) {
        if (!table.description)
            return '';
        const comment = this.escapeString(table.description, databaseType);
        const tableName = this.quoteIdentifier(table.name, databaseType);
        const schemaPrefix = schemaName !== 'public' ? `${this.quoteIdentifier(schemaName, databaseType)}.` : '';
        if (databaseType === 'postgresql') {
            return `COMMENT ON TABLE ${schemaPrefix}${tableName} IS '${comment}';`;
        }
        else if (databaseType === 'mysql' || databaseType === 'mariadb') {
            return `ALTER TABLE ${schemaPrefix}${tableName} COMMENT = '${comment}';`;
        }
        return '';
    }
    /**
     * Quote identifier based on database type
     */
    quoteIdentifier(identifier, databaseType) {
        switch (databaseType) {
            case 'postgresql':
                return `"${identifier}"`;
            case 'mysql':
            case 'mariadb':
                return `\`${identifier}\``;
            case 'sqlserver':
                return `[${identifier}]`;
            default:
                return identifier;
        }
    }
    /**
     * Escape string for SQL
     */
    escapeString(str, databaseType) {
        return str.replace(/'/g, "''");
    }
    /**
     * Format default value
     */
    formatDefaultValue(value, dataType) {
        // For string types, wrap in quotes
        if (['varchar', 'text', 'char', 'json', 'jsonb'].includes(dataType)) {
            return `'${value.replace(/'/g, "''")}'`;
        }
        // For boolean types
        if (dataType === 'boolean') {
            return value.toLowerCase() === 'true' ? 'TRUE' : 'FALSE';
        }
        // For other types, return as is
        return value;
    }
}
exports.SQLExportService = SQLExportService;
//# sourceMappingURL=sqlExportService.js.map